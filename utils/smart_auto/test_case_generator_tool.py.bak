"""
测试用例生成功能模块
基于LangChain工具实现，用于根据API文档自动生成测试用例
"""

import os
import json
import yaml
import random
import string
from typing import Dict, List, Any, Optional, Tuple
from pydantic import BaseModel
from langchain.tools import BaseTool
from dataclasses import dataclass
from langchain.tools import BaseTool
from pydantic import BaseModel, Field
import random
import string
from .test_generator import TestCase, TestSuite
from .openapi_parser_tool import OpenAPIParseTool


@dataclass
class GeneratedTestCase:
    """生成的测试用例"""
    name: str
    description: str
    method: str
    url: str
    headers: Dict[str, str]
    params: Dict[str, Any]
    body: Optional[Dict[str, Any]]
    expected_status: int
    expected_response: Optional[Dict[str, Any]]
    assertions: List[Dict[str, Any]]


@dataclass
class GeneratedTestSuite:
    """生成的测试套件"""
    name: str
    description: str
    test_cases: List[GeneratedTestCase]
    setup: Optional[Dict[str, Any]]
    teardown: Optional[Dict[str, Any]]


class TestCaseGeneratorInput(BaseModel):
    """测试用例生成工具输入模型"""
    file_id: str = Field(description="文件ID，用于从指定路径读取OpenAPI文档、API依赖关系和测试场景")
    test_type: str = Field(description="测试类型：basic(基础测试)、boundary(边界测试)、error(错误测试)、scene(场景测试)或all(全部)")
    num_cases: Optional[int] = Field(description="每个API生成的测试用例数量，默认为3")


class TestCaseGeneratorTool(BaseTool):
    """测试用例生成工具"""
    name = "test_case_generator_tool"
    description = "根据OpenAPI 3.0.0文档自动生成API测试用例"
    args_schema: type[BaseModel] = TestCaseGeneratorInput
    
    def _load_openapi_document(self, file_id: str) -> Dict[str, Any]:
        """加载OpenAPI文档"""
        try:
            # 尝试YAML格式
            yaml_path = os.path.join("/Users/oss/code/PytestAutoApi/uploads/openapi", f"openapi_{file_id}.yaml")
            if os.path.exists(yaml_path):
                with open(yaml_path, 'r', encoding='utf-8') as f:
                    return yaml.safe_load(f)
            
            # 尝试JSON格式
            json_path = os.path.join("/Users/oss/code/PytestAutoApi/uploads/openapi", f"openapi_{file_id}.json")
            if os.path.exists(json_path):
                with open(json_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            
            return {"error": f"未找到file_id为{file_id}的OpenAPI文档"}
        except Exception as e:
            return {"error": f"加载OpenAPI文档失败: {str(e)}"}
    
    def _load_api_relation(self, file_id: str) -> Dict[str, Any]:
        """加载API依赖关系"""
        try:
            relation_path = os.path.join("/Users/oss/code/PytestAutoApi/uploads/relation", f"relation_{file_id}.json")
            if os.path.exists(relation_path):
                with open(relation_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            
            return {"error": f"未找到file_id为{file_id}的API依赖关系文件"}
        except Exception as e:
            return {"error": f"加载API依赖关系失败: {str(e)}"}
    
    def _load_test_scene(self, file_id: str) -> Dict[str, Any]:
        """加载测试场景"""
        try:
            scene_path = os.path.join("/Users/oss/code/PytestAutoApi/uploads/scene", f"scene_{file_id}.json")
            if os.path.exists(scene_path):
                with open(scene_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            
            return {"error": f"未找到file_id为{file_id}的测试场景文件"}
        except Exception as e:
            return {"error": f"加载测试场景失败: {str(e)}"}
    
    def _run(self, file_id: str, test_type: str = "all", num_cases: int = 3) -> Dict[str, Any]:
        """执行测试用例生成"""
        try:
            # 使用file_id加载OpenAPI文档、API依赖关系和测试场景
            openapi_doc = self._load_openapi_document(file_id)
            if "error" in openapi_doc:
                return openapi_doc
            
            api_relation = self._load_api_relation(file_id)
            if "error" in api_relation:
                return api_relation
                
            test_scene = self._load_test_scene(file_id)
            if "error" in test_scene:
                return test_scene
            
            # 从OpenAPI文档中提取端点信息
            endpoints = []
            if "paths" in openapi_doc:
                for path, path_item in openapi_doc["paths"].items():
                    for method, operation in path_item.items():
                        if method.lower() in ["get", "post", "put", "delete", "patch"]:
                            endpoints.append({
                                "method": method.upper(),
                                "path": path,
                                "operation": operation,
                                "parameters": operation.get("parameters", []),
                                "requestBody": operation.get("requestBody"),
                                "responses": operation.get("responses", {})
                            })
            
            schemas = openapi_doc.get("components", {}).get("schemas", {})
            base_url = openapi_doc.get("servers", [{}])[0].get("url", "")
            
            # 添加调试信息
            print(f"DEBUG: Found {len(endpoints)} endpoints")
            if len(endpoints) > 0:
                print(f"DEBUG: First endpoint: {endpoints[0]}")
            
            # 生成测试用例
            test_suites = []
            
            # 根据测试类型选择不同的生成策略
            if test_type == "scene":
                # 基于场景生成测试用例
                test_suites = self._generate_scene_based_test_cases(
                    endpoints, schemas, base_url, api_relation, test_scene, num_cases
                )
            else:
                # 基于端点生成测试用例（原有逻辑）
                for i, endpoint in enumerate(endpoints):
                    print(f"DEBUG: Processing endpoint {i+1}/{len(endpoints)}: {endpoint.get('method')} {endpoint.get('path')}")
                    
                    method = endpoint["method"]
                    path = endpoint["path"]
                    endpoint_name = f"{method}_{path.replace('/', '_').replace('{', '').replace('}', '')}"
                    
                    # 生成不同类型的测试用例
                    test_cases = []
                    
                    if test_type in ["basic", "all"]:
                        basic_cases = self._generate_basic_test_cases(endpoint, schemas, base_url, num_cases)
                        print(f"DEBUG: Generated {len(basic_cases)} basic test cases for {method} {path}")
                        test_cases.extend(basic_cases)
                    
                    if test_type in ["boundary", "all"]:
                        boundary_cases = self._generate_boundary_test_cases(endpoint, schemas, base_url, num_cases)
                        print(f"DEBUG: Generated {len(boundary_cases)} boundary test cases for {method} {path}")
                        test_cases.extend(boundary_cases)
                    
                    if test_type in ["error", "all"]:
                        error_cases = self._generate_error_test_cases(endpoint, schemas, base_url, num_cases)
                        print(f"DEBUG: Generated {len(error_cases)} error test cases for {method} {path}")
                        test_cases.extend(error_cases)
                    
                    print(f"DEBUG: Total test cases for {method} {path}: {len(test_cases)}")
                    
                    # 创建测试套件
                    test_suite = GeneratedTestSuite(
                        name=f"{endpoint_name}_test_suite",
                        description=f"测试{method} {path}接口",
                        test_cases=test_cases,
                        setup=self._generate_setup(endpoint),
                        teardown=self._generate_teardown(endpoint)
                    )
                    
                    test_suites.append(test_suite)
            
            print(f"DEBUG: Total test suites: {len(test_suites)}")
            print(f"DEBUG: Total test cases: {sum(len(suite.test_cases) for suite in test_suites)}")
            
            # 生成测试套件汇总
            summary = self._generate_test_summary(test_suites)
            
            return {
                "test_suites": [
                    {
                        "name": suite.name,
                        "description": suite.description,
                        "test_cases": [
                            {
                                "name": case.name,
                                "description": case.description,
                                "method": case.method,
                                "url": case.url,
                                "headers": case.headers,
                                "params": case.params,
                                "body": case.body,
                                "expected_status": case.expected_status,
                                "expected_response": case.expected_response,
                                "assertions": case.assertions
                            } for case in suite.test_cases
                        ],
                        "setup": suite.setup,
                        "teardown": suite.teardown
                    } for suite in test_suites
                ],
                "summary": summary
            }
            
        except Exception as e:
            return {"error": f"生成测试用例失败: {str(e)}"}
    
    def _generate_basic_test_cases(self, endpoint: Dict, schemas: Dict, base_url: str, num_cases: int) -> List[GeneratedTestCase]:
        """生成基础测试用例"""
        test_cases = []
        method = endpoint["method"]
        path = endpoint["path"]
        
        # 生成正常情况测试用例
        for i in range(min(num_cases, 2)):
            case_name = f"test_{method.lower()}_{path.replace('/', '_').replace('{', '').replace('}', '')}_basic_{i+1}"
            
            # 生成参数
            params = self._generate_params(endpoint, schemas, "basic")
            
            # 生成请求体
            body = self._generate_request_body(endpoint, schemas, "basic")
            
            # 生成预期响应
            expected_status = self._get_expected_success_status(method)
            expected_response = self._generate_expected_response(endpoint, schemas, expected_status)
            
            # 生成断言
            assertions = self._generate_assertions(endpoint, expected_status, expected_response)
            
            # 构建URL，避免重复路径
            if base_url and path.startswith(base_url):
                # 如果path已经包含base_url，直接使用path
                url = path
            else:
                # 否则组合base_url和path
                url = f"{base_url}{path}"
            
            test_case = GeneratedTestCase(
                name=case_name,
                description=f"测试{method} {path}接口 - 基础测试用例{i+1}",
                method=method,
                url=url,
                headers=self._generate_headers(endpoint),
                params=params,
                body=body,
                expected_status=expected_status,
                expected_response=expected_response,
                assertions=assertions
            )
            
            test_cases.append(test_case)
        
        return test_cases
    
    def _generate_boundary_test_cases(self, endpoint: Dict, schemas: Dict, base_url: str, num_cases: int) -> List[GeneratedTestCase]:
        """生成边界测试用例"""
        test_cases = []
        method = endpoint["method"]
        path = endpoint["path"]
        
        # 生成边界值测试用例
        boundary_cases = [
            {"name": "empty_params", "description": "空参数测试"},
            {"name": "max_length", "description": "最大长度测试"},
            {"name": "min_length", "description": "最小长度测试"}
        ]
        
        for i, case_type in enumerate(boundary_cases[:min(num_cases, len(boundary_cases))]):
            case_name = f"test_{method.lower()}_{path.replace('/', '_').replace('{', '').replace('}', '')}_boundary_{case_type['name']}"
            
            # 生成参数
            params = self._generate_params(endpoint, schemas, "boundary", case_type["name"])
            
            # 生成请求体
            body = self._generate_request_body(endpoint, schemas, "boundary", case_type["name"])
            
            # 生成预期响应
            expected_status = self._get_expected_success_status(method)
            expected_response = self._generate_expected_response(endpoint, schemas, expected_status)
            
            # 生成断言
            assertions = self._generate_assertions(endpoint, expected_status, expected_response)
            
            # 构建URL，避免重复路径
            if base_url and path.startswith(base_url):
                # 如果path已经包含base_url，直接使用path
                url = path
            else:
                # 否则组合base_url和path
                url = f"{base_url}{path}"
            
            test_case = GeneratedTestCase(
                name=case_name,
                description=f"测试{method} {path}接口 - {case_type['description']}",
                method=method,
                url=url,
                headers=self._generate_headers(endpoint),
                params=params,
                body=body,
                expected_status=expected_status,
                expected_response=expected_response,
                assertions=assertions
            )
            
            test_cases.append(test_case)
        
        return test_cases
    
    def _generate_error_test_cases(self, endpoint: Dict, schemas: Dict, base_url: str, num_cases: int) -> List[GeneratedTestCase]:
        """生成错误测试用例"""
        test_cases = []
        method = endpoint["method"]
        path = endpoint["path"]
        
        # 生成错误情况测试用例
        error_cases = [
            {"name": "invalid_method", "description": "无效HTTP方法测试", "status": 405},
            {"name": "missing_required", "description": "缺少必需参数测试", "status": 400},
            {"name": "invalid_format", "description": "无效格式测试", "status": 400},
            {"name": "unauthorized", "description": "未授权测试", "status": 401}
        ]
        
        for i, case_type in enumerate(error_cases[:min(num_cases, len(error_cases))]):
            case_name = f"test_{method.lower()}_{path.replace('/', '_').replace('{', '').replace('}', '')}_error_{case_type['name']}"
            
            # 生成参数
            params = self._generate_params(endpoint, schemas, "error", case_type["name"])
            
            # 生成请求体
            body = self._generate_request_body(endpoint, schemas, "error", case_type["name"])
            
            # 生成预期响应
            expected_status = case_type["status"]
            expected_response = self._generate_expected_response(endpoint, schemas, expected_status)
            
            # 生成断言
            assertions = self._generate_assertions(endpoint, expected_status, expected_response)
            
            # 构建URL，避免重复路径
            if base_url and path.startswith(base_url):
                # 如果path已经包含base_url，直接使用path
                url = path
            else:
                # 否则组合base_url和path
                url = f"{base_url}{path}"
            
            test_case = GeneratedTestCase(
                name=case_name,
                description=f"测试{method} {path}接口 - {case_type['description']}",
                method=method,
                url=url,
                headers=self._generate_headers(endpoint),
                params=params,
                body=body,
                expected_status=expected_status,
                expected_response=expected_response,
                assertions=assertions
            )
            
            test_cases.append(test_case)
        
        return test_cases
    
    def _generate_scene_based_test_cases(self, endpoints: List[Dict], schemas: Dict, base_url: str, 
                                        api_relation: Dict, test_scene: Dict, num_cases: int) -> List[GeneratedTestSuite]:
        """基于场景生成测试用例"""
        test_suites = []
        
        # 从测试场景中提取业务场景
        scenes = test_scene.get("scenes", [])
        
        for scene in scenes:
            scene_name = scene.get("name", "未命名场景")
            scene_description = scene.get("description", "")
            scene_steps = scene.get("steps", [])
            
            # 为每个场景创建测试套件
            test_cases = []
            
            for step in scene_steps:
                step_name = step.get("name", "")
                step_description = step.get("description", "")
                api_path = step.get("api_path", "")
                method = step.get("method", "GET")
                
                # 查找对应的端点
                endpoint = None
                for ep in endpoints:
                    if ep["path"] == api_path and ep["method"] == method.upper():
                        endpoint = ep
                        break
                
                if not endpoint:
                    print(f"WARNING: 未找到API端点 {method} {api_path}")
                    continue
                
                # 生成测试用例
                case_name = f"test_{scene_name}_{step_name}".replace(" ", "_").lower()
                
                # 生成参数
                params = self._generate_params(endpoint, schemas, "scene", scene, step)
                
                # 生成请求体
                body = self._generate_request_body(endpoint, schemas, "scene", scene, step)
                
                # 生成预期响应
                expected_status = self._get_expected_success_status(method)
                expected_response = self._generate_expected_response(endpoint, schemas, expected_status)
                
                # 生成断言
                assertions = self._generate_assertions(endpoint, expected_status, expected_response)
                
                # 构建URL，避免重复路径
                if base_url and api_path.startswith(base_url):
                    # 如果path已经包含base_url，直接使用path
                    url = api_path
                else:
                    # 否则组合base_url和path
                    url = f"{base_url}{api_path}"
                
                test_case = GeneratedTestCase(
                    name=case_name,
                    description=f"测试场景'{scene_name}'中的步骤'{step_name}': {step_description}",
                    method=method.upper(),
                    url=url,
                    headers=self._generate_headers(endpoint),
                    params=params,
                    body=body,
                    expected_status=expected_status,
                    expected_response=expected_response,
                    assertions=assertions
                )
                
                test_cases.append(test_case)
            
            # 创建测试套件
            test_suite = GeneratedTestSuite(
                name=f"{scene_name}_test_suite",
                description=f"测试场景: {scene_description}",
                test_cases=test_cases,
                setup=self._generate_scene_setup(scene, api_relation),
                teardown=self._generate_scene_teardown(scene, api_relation)
            )
            
            test_suites.append(test_suite)
        
        # 如果没有场景，则基于API依赖关系生成测试用例
        if not test_suites and api_relation:
            test_suites = self._generate_relation_based_test_cases(endpoints, schemas, base_url, api_relation, num_cases)
        
        return test_suites
    
    def _generate_relation_based_test_cases(self, endpoints: List[Dict], schemas: Dict, base_url: str,
                                          api_relation: Dict, num_cases: int) -> List[GeneratedTestSuite]:
        """基于API依赖关系生成测试用例"""
        test_suites = []
        
        # 从API依赖关系中提取信息
        global_apis = api_relation.get("global_apis", [])
        conditional_apis = api_relation.get("conditional_apis", [])
        data_flow = api_relation.get("data_flow", [])
        
        # 为全局API生成测试用例
        if global_apis:
            test_cases = []
            for api_info in global_apis[:min(num_cases, len(global_apis))]:
                api_path = api_info.get("path", "")
                method = api_info.get("method", "GET")
                description = api_info.get("description", "")
                
                # 查找对应的端点
                endpoint = None
                for ep in endpoints:
                    if ep["path"] == api_path and ep["method"] == method.upper():
                        endpoint = ep
                        break
                
                if not endpoint:
                    continue
                
                # 生成测试用例
                case_name = f"test_global_{method.lower()}_{api_path.replace('/', '_').replace('{', '').replace('}', '')}"
                
                # 生成参数
                params = self._generate_params(endpoint, schemas, "relation", api_info)
                
                # 生成请求体
                body = self._generate_request_body(endpoint, schemas, "relation", api_info)
                
                # 生成预期响应
                expected_status = self._get_expected_success_status(method)
                expected_response = self._generate_expected_response(endpoint, schemas, expected_status)
                
                # 生成断言
                assertions = self._generate_assertions(endpoint, expected_status, expected_response)
                
                # 构建URL
                if base_url and api_path.startswith(base_url):
                    url = api_path
                else:
                    url = f"{base_url}{api_path}"
                
                test_case = GeneratedTestCase(
                    name=case_name,
                    description=f"测试全局API: {description}",
                    method=method.upper(),
                    url=url,
                    headers=self._generate_headers(endpoint),
                    params=params,
                    body=body,
                    expected_status=expected_status,
                    expected_response=expected_response,
                    assertions=assertions
                )
                
                test_cases.append(test_case)
            
            if test_cases:
                test_suite = GeneratedTestSuite(
                    name="global_apis_test_suite",
                    description="测试全局API",
                    test_cases=test_cases,
                    setup=self._generate_relation_setup(api_relation),
                    teardown=self._generate_relation_teardown(api_relation)
                )
                
                test_suites.append(test_suite)
        
        # 为条件API生成测试用例
        if conditional_apis:
            test_cases = []
            for api_info in conditional_apis[:min(num_cases, len(conditional_apis))]:
                api_path = api_info.get("path", "")
                method = api_info.get("method", "GET")
                condition = api_info.get("condition", "")
                description = api_info.get("description", "")
                
                # 查找对应的端点
                endpoint = None
                for ep in endpoints:
                    if ep["path"] == api_path and ep["method"] == method.upper():
                        endpoint = ep
                        break
                
                if not endpoint:
                    continue
                
                # 生成测试用例
                case_name = f"test_conditional_{method.lower()}_{api_path.replace('/', '_').replace('{', '').replace('}', '')}"
                
                # 生成参数
                params = self._generate_params(endpoint, schemas, "relation", api_info)
                
                # 生成请求体
                body = self._generate_request_body(endpoint, schemas, "relation", api_info)
                
                # 生成预期响应
                expected_status = self._get_expected_success_status(method)
                expected_response = self._generate_expected_response(endpoint, schemas, expected_status)
                
                # 生成断言
                assertions = self._generate_assertions(endpoint, expected_status, expected_response)
                
                # 构建URL
                if base_url and api_path.startswith(base_url):
                    url = api_path
                else:
                    url = f"{base_url}{api_path}"
                
                test_case = GeneratedTestCase(
                    name=case_name,
                    description=f"测试条件API: {description} (条件: {condition})",
                    method=method.upper(),
                    url=url,
                    headers=self._generate_headers(endpoint),
                    params=params,
                    body=body,
                    expected_status=expected_status,
                    expected_response=expected_response,
                    assertions=assertions
                )
                
                test_cases.append(test_case)
            
            if test_cases:
                test_suite = GeneratedTestSuite(
                    name="conditional_apis_test_suite",
                    description="测试条件API",
                    test_cases=test_cases,
                    setup=self._generate_relation_setup(api_relation),
                    teardown=self._generate_relation_teardown(api_relation)
                )
                
                test_suites.append(test_suite)
        
        return test_suites
    
    def _generate_scene_setup(self, scene: Dict, api_relation: Dict) -> Optional[Dict[str, Any]]:
        """生成场景测试的前置条件"""
        # 从场景中提取前置条件
        preconditions = scene.get("preconditions", [])
        
        if not preconditions:
            return None
        
        setup_steps = []
        for condition in preconditions:
            setup_steps.append({
                "action": condition.get("action", ""),
                "description": condition.get("description", ""),
                "parameters": condition.get("parameters", {})
            })
        
        return {
            "type": "scene_setup",
            "description": f"为场景'{scene.get('name', '')}'设置前置条件",
            "steps": setup_steps
        }
    
    def _generate_scene_teardown(self, scene: Dict, api_relation: Dict) -> Optional[Dict[str, Any]]:
        """生成场景测试的后置条件"""
        # 从场景中提取后置条件
        postconditions = scene.get("postconditions", [])
        
        if not postconditions:
            return None
        
        teardown_steps = []
        for condition in postconditions:
            teardown_steps.append({
                "action": condition.get("action", ""),
                "description": condition.get("description", ""),
                "parameters": condition.get("parameters", {})
            })
        
        return {
            "type": "scene_teardown",
            "description": f"为场景'{scene.get('name', '')}'清理后置条件",
            "steps": teardown_steps
        }
    
    def _generate_relation_setup(self, api_relation: Dict) -> Optional[Dict[str, Any]]:
        """生成依赖关系测试的前置条件"""
        # 从API依赖关系中提取前置条件
        setup_requirements = api_relation.get("setup_requirements", [])
        
        if not setup_requirements:
            return None
        
        setup_steps = []
        for requirement in setup_requirements:
            setup_steps.append({
                "action": requirement.get("action", ""),
                "description": requirement.get("description", ""),
                "parameters": requirement.get("parameters", {})
            })
        
        return {
            "type": "relation_setup",
            "description": "为API依赖关系测试设置前置条件",
            "steps": setup_steps
        }
    
    def _generate_relation_teardown(self, api_relation: Dict) -> Optional[Dict[str, Any]]:
        """生成依赖关系测试的后置条件"""
        # 从API依赖关系中提取后置条件
        teardown_requirements = api_relation.get("teardown_requirements", [])
        
        if not teardown_requirements:
            return None
        
        teardown_steps = []
        for requirement in teardown_requirements:
            teardown_steps.append({
                "action": requirement.get("action", ""),
                "description": requirement.get("description", ""),
                "parameters": requirement.get("parameters", {})
            })
        
        return {
            "type": "relation_teardown",
            "description": "为API依赖关系测试清理后置条件",
            "steps": teardown_steps
        }
    
    def _generate_params(self, endpoint: Dict, schemas: Dict, test_type: str, *args) -> Dict[str, Any]:
        """生成请求参数"""
        params = {}
        
        if test_type == "scene":
            # 从场景参数中提取
            scene, step = args
            step_params = step.get("parameters", {})
            
            for param in endpoint.get("parameters", []):
                param_name = param.get("name", "")
                param_in = param.get("in", "")
                
                if param_in == "query" and param_name in step_params:
                    params[param_name] = step_params[param_name]
                elif param_in == "query" and param_name not in step_params:
                    # 使用默认值
                    param_type = param.get("schema", {}).get("type", "string")
                    params[param_name] = self._generate_basic_value(param_type, param.get("schema", {}))
        elif test_type == "relation":
            # 从依赖关系参数中提取
            api_info = args[0]
            api_params = api_info.get("parameters", {})
            
            for param in endpoint.get("parameters", []):
                param_name = param.get("name", "")
                param_in = param.get("in", "")
                
                if param_in == "query" and param_name in api_params:
                    params[param_name] = api_params[param_name]
                elif param_in == "query" and param_name not in api_params:
                    # 使用默认值
                    param_type = param.get("schema", {}).get("type", "string")
                    params[param_name] = self._generate_basic_value(param_type, param.get("schema", {}))
        else:
            # 原有的参数生成逻辑
            for param in endpoint.get("parameters", []):
                param_name = param.get("name", "")
                param_in = param.get("in", "")
                
                if param_in == "query":
                    param_type = param.get("schema", {}).get("type", "string")
                    params[param_name] = self._generate_basic_value(param_type, param.get("schema", {}))
        
        return params
    
    def _generate_request_body(self, endpoint: Dict, schemas: Dict, test_type: str, *args) -> Optional[Dict[str, Any]]:
        """生成请求体"""
        request_body = endpoint.get("requestBody")
        
        if not request_body:
            return None
        
        content = request_body.get("content", {})
        json_content = content.get("application/json")
        
        if not json_content:
            return None
        
        schema = json_content.get("schema", {})
        
        if test_type == "scene":
            # 从场景参数中提取
            scene, step = args
            step_body = step.get("body", {})
            
            if step_body:
                return step_body
            else:
                return self._generate_basic_object(schema, schemas)
        elif test_type == "relation":
            # 从依赖关系参数中提取
            api_info = args[0]
            api_body = api_info.get("body", {})
            
            if api_body:
                return api_body
            else:
                return self._generate_basic_object(schema, schemas)
        else:
            # 原有的请求体生成逻辑
            return self._generate_basic_object(schema, schemas)
    
    def _generate_test_summary(self, test_suites: List[GeneratedTestSuite]) -> Dict[str, Any]:
        """生成测试汇总"""
        total_suites = len(test_suites)
        total_cases = sum(len(suite.test_cases) for suite in test_suites)
        
        # 按测试类型统计
        basic_cases = 0
        boundary_cases = 0
        error_cases = 0
        scene_cases = 0
        relation_cases = 0
        
        for suite in test_suites:
            for case in suite.test_cases:
                if "basic" in case.name:
                    basic_cases += 1
                elif "boundary" in case.name:
                    boundary_cases += 1
                elif "error" in case.name:
                    error_cases += 1
                elif "scene" in case.name or "global" in case.name or "conditional" in case.name:
                    if "scene" in suite.name:
                        scene_cases += 1
                    else:
                        relation_cases += 1
        
        return {
            "total_suites": total_suites,
            "total_cases": total_cases,
            "basic_cases": basic_cases,
            "boundary_cases": boundary_cases,
            "error_cases": error_cases,
            "scene_cases": scene_cases,
            "relation_cases": relation_cases
        }


def create_test_generator_tools():
    """创建测试用例生成相关的工具集"""
    return [
        TestCaseGeneratorTool()
    ]

    def _generate_basic_value(self, param_type: str, param: Dict) -> Any:
        """生成基础值"""
        if param_type == "string":
            if "enum" in param:
                return random.choice(param["enum"])
            elif param.get("format") == "email":
                return f"test{random.randint(1, 1000)}@example.com"
            elif param.get("format") == "date":
                return "2023-01-01"
            elif param.get("format") == "date-time":
                return "2023-01-01T00:00:00Z"
            else:
                return f"test_{random.randint(1, 1000)}"
        elif param_type == "integer":
            minimum = param.get("minimum", 1)
            maximum = param.get("maximum", 100)
            return random.randint(minimum, maximum)
        elif param_type == "number":
            minimum = param.get("minimum", 1.0)
            maximum = param.get("maximum", 100.0)
            return round(random.uniform(minimum, maximum), 2)
        elif param_type == "boolean":
            return random.choice([True, False])
        else:
            return f"test_{random.randint(1, 1000)}"
    
    def _generate_boundary_value(self, param_type: str, param: Dict, case_type: str) -> Any:
        """生成边界值"""
        if case_type == "empty_params":
            return "" if param_type == "string" else 0
        elif case_type == "max_length":
            if param_type == "string":
                max_length = param.get("maxLength", 50)
                return "".join(random.choices(string.ascii_letters + string.digits, k=max_length))
            elif param_type in ["integer", "number"]:
                return param.get("maximum", 100)
            else:
                return self._generate_basic_value(param_type, param)
        elif case_type == "min_length":
            if param_type == "string":
                min_length = param.get("minLength", 1)
                return "".join(random.choices(string.ascii_letters + string.digits, k=min_length))
            elif param_type in ["integer", "number"]:
                return param.get("minimum", 1)
            else:
                return self._generate_basic_value(param_type, param)
        else:
            return self._generate_basic_value(param_type, param)
    
    def _generate_error_value(self, param_type: str, param: Dict, case_type: str) -> Any:
        """生成错误值"""
        if case_type == "missing_required":
            return None  # 将在调用处处理
        elif case_type == "invalid_format":
            if param_type == "string":
                if param.get("format") == "email":
                    return "invalid-email"
                elif param.get("format") == "date":
                    return "invalid-date"
                else:
                    return 123  # 类型错误
            elif param_type in ["integer", "number"]:
                return "not-a-number"
            elif param_type == "boolean":
                return "not-a-boolean"
            else:
                return None
        else:
            return self._generate_basic_value(param_type, param)
    
    def _generate_basic_object(self, schema: Dict, schemas: Dict) -> Dict[str, Any]:
        """生成基础对象"""
        obj = {}
        
        if "$ref" in schema:
            ref_name = schema["$ref"].split("/")[-1]
            if ref_name in schemas:
                schema = schemas[ref_name]
        
        if "properties" in schema:
            properties = schema["properties"]
            required_fields = schema.get("required", [])
            
            for prop_name, prop_schema in properties.items():
                # 只生成必需字段和一些可选字段
                if prop_name in required_fields or random.random() > 0.5:
                    prop_type = prop_schema.get("type", "string")
                    obj[prop_name] = self._generate_basic_value(prop_type, prop_schema)
        
        return obj
    
    def _generate_boundary_object(self, schema: Dict, schemas: Dict, case_type: str) -> Dict[str, Any]:
        """生成边界对象"""
        obj = self._generate_basic_object(schema, schemas)
        
        if case_type == "empty_params":
            return {}
        elif case_type == "max_length":
            # 对字符串字段设置最大长度
            for key, value in obj.items():
                if isinstance(value, str):
                    obj[key] = value * 10  # 简单地放大字符串长度
            return obj
        elif case_type == "min_length":
            # 对字符串字段设置最小长度
            for key, value in obj.items():
                if isinstance(value, str) and len(value) > 1:
                    obj[key] = value[0]  # 只保留一个字符
            return obj
        else:
            return obj
    
    def _generate_error_object(self, schema: Dict, schemas: Dict, case_type: str) -> Dict[str, Any]:
        """生成错误对象"""
        if case_type == "missing_required":
            # 返回空对象，缺少必需字段
            return {}
        elif case_type == "invalid_format":
            # 生成类型错误的对象
            obj = self._generate_basic_object(schema, schemas)
            for key, value in obj.items():
                if isinstance(value, str):
                    obj[key] = 123  # 将字符串改为数字
                elif isinstance(value, (int, float)):
                    obj[key] = "not-a-number"  # 将数字改为字符串
                elif isinstance(value, bool):
                    obj[key] = "not-a-boolean"  # 将布尔值改为字符串
            return obj
        else:
            return self._generate_basic_object(schema, schemas)
    
    def _generate_headers(self, endpoint: Dict) -> Dict[str, str]:
        """生成请求头"""
        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json"
        }
        
        # 如果API需要认证，添加认证头
        if endpoint.get("security"):
            # 这里简化处理，实际应根据安全方案生成相应的认证头
            headers["Authorization"] = "Bearer test-token"
        
        return headers
    
    def _get_expected_success_status(self, method: str) -> int:
        """获取预期成功状态码"""
        if method == "POST":
            return 201
        elif method == "DELETE":
            return 204
        else:
            return 200
    
    def _generate_expected_response(self, endpoint: Dict, schemas: Dict, status_code: int) -> Optional[Dict[str, Any]]:
        """生成预期响应"""
        responses = endpoint.get("responses", {})
        response = responses.get(str(status_code))
        
        if not response:
            # 如果没有找到对应状态码的响应，使用默认响应
            if str(status_code).startswith("2"):
                response = responses.get("200") or responses.get("default")
            else:
                response = responses.get("default")
        
        if not response:
            return None
        
        content = response.get("content", {})
        json_content = content.get("application/json")
        
        if not json_content:
            return None
        
        schema = json_content.get("schema", {})
        
        # 根据模式生成示例响应
        return self._generate_basic_object(schema, schemas)
    
    def _generate_assertions(self, endpoint: Dict, expected_status: int, expected_response: Optional[Dict]) -> List[Dict[str, Any]]:
        """生成断言"""
        assertions = [
            {
                "type": "status",
                "expected": expected_status,
                "description": f"验证状态码为{expected_status}"
            }
        ]
        
        if expected_response:
            assertions.append({
                "type": "response_time",
                "expected": "< 5000",
                "description": "验证响应时间小于5秒"
            })
            
            # 如果有响应体，添加JSON结构验证
            if isinstance(expected_response, dict) and expected_response:
                assertions.append({
                    "type": "json_structure",
                    "expected": list(expected_response.keys()),
                    "description": "验证响应JSON结构"
                })
        
        return assertions